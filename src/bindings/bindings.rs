#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(improper_ctypes)]
/* automatically generated by rust-bindgen 0.63.0 */

pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    #[doc = " Get default transport name.\n\n Currently, this is the default location of the Unix socket."]
    pub fn lldpctl_get_default_transport() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldpctl_conn_t {
    _unused: [u8; 0],
}
#[doc = " Callback function invoked to send data to lldpd.\n\n @param conn      Handle to the connection to lldpd.\n @param data      Bytes to be sent.\n @param length    Length of provided data.\n @param user_data Provided user data.\n @return The number of bytes really sent or either @c LLDPCTL_ERR_WOULDBLOCK\n         if no bytes can be sent without blocking or @c\n         LLDPCTL_ERR_CALLBACK_FAILURE for other errors."]
pub type lldpctl_send_callback = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut lldpctl_conn_t,
        data: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> isize,
>;
#[doc = " Callback function invoked to receive data from lldpd.\n\n @param conn      Handle to the connection to lldpd.\n @param data      Buffer for receiving data\n @param length    Maximum bytes we can receive\n @param user_data Provided user data.\n @return The number of bytes really received or either @c\n         LLDPCTL_ERR_WOULDBLOCK if no bytes can be received without blocking,\n         @c LLDPCTL_ERR_CALLBACK_FAILURE for other errors or @c\n         LLDPCTL_ERR_EOF if end of file was reached."]
pub type lldpctl_recv_callback = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut lldpctl_conn_t,
        data: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> isize,
>;
extern "C" {
    #[doc = " Function invoked when additional data is available from lldpd.\n\n This function should be invoked in case of asynchronous IO when new data is\n available from lldpd (expected or unexpected).\n\n @param  conn      Handle to the connection to lldpd.\n @param  data      Data received from lldpd.\n @param  length    Length of data received.\n @return The number of bytes available or a negative integer if an error has\n         occurred. 0 is not an error. It usually means that a notification has\n         been processed."]
    pub fn lldpctl_recv(conn: *mut lldpctl_conn_t, data: *const u8, length: usize) -> isize;
}
extern "C" {
    #[doc = " Function invoked when there is an opportunity to send data to lldpd.\n\n This function should be invoked in case of asynchronous IO when new data can\n be written to lldpd.\n\n @param  conn  Handle to the connection to lldpd.\n @return The number of bytes processed or a negative integer if an error has\n         occurred."]
    pub fn lldpctl_send(conn: *mut lldpctl_conn_t) -> isize;
}
extern "C" {
    #[doc = " Function invoked to see if there's more data to be processed in the buffer.\n\n This function should be invoked to check for notifications in the data that\n has already been read. Its used typically for asynchronous connections.\n\n @param  conn  Handle to the connection to lldpd.\n @return 0 to indicate maybe more data is available for processing\n         !0 to indicate no data or insufficient data for processing"]
    pub fn lldpctl_process_conn_buffer(conn: *mut lldpctl_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new handler for connecting to lldpd.\n\n @param  send      Callback to be used when sending   new data is requested.\n @param  recv      Callback to be used when receiving new data is requested.\n @param  user_data Data to pass to callbacks.\n @return An handler to be used to connect to lldpd or @c NULL in\n         case of error. In the later case, the error is probable an\n         out of memory condition.\n\n The allocated handler can be released with @c lldpctl_release(). If the\n provided parameters are both @c NULL, default synchronous callbacks will be\n used."]
    pub fn lldpctl_new(
        send: lldpctl_send_callback,
        recv: lldpctl_recv_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut lldpctl_conn_t;
}
extern "C" {
    #[doc = " Allocate a new handler for connecting to lldpd.\n\n @param  ctlname   the Unix-domain socket to connect to lldpd.\n @param  send      Callback to be used when sending   new data is requested.\n @param  recv      Callback to be used when receiving new data is requested.\n @param  user_data Data to pass to callbacks.\n @return An handler to be used to connect to lldpd or @c NULL in\n         case of error. In the later case, the error is probable an\n         out of memory condition.\n\n The allocated handler can be released with @c lldpctl_release(). If the\n provided parameters are both @c NULL, default synchronous callbacks will be\n used."]
    pub fn lldpctl_new_name(
        ctlname: *const ::std::os::raw::c_char,
        send: lldpctl_send_callback,
        recv: lldpctl_recv_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut lldpctl_conn_t;
}
extern "C" {
    #[doc = " Release resources associated with a connection to lldpd.\n\n @param   conn Previously allocated handler to a connection to lldpd.\n @return  0 on success or a negative integer\n\n @see lldpctl_new()"]
    pub fn lldpctl_release(conn: *mut lldpctl_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setup log handlers.\n\n By default, liblldpctl will log to stderr. The following function will\n register another callback for this purpose. Messages logged through this\n callback may be cryptic. They are targeted for the developer. Message for end\n users should rely on return codes."]
    pub fn lldpctl_log_callback(
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                severity: ::std::os::raw::c_int,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Setup log level.\n\n By default, liblldpctl will only log warnings. The following function allows\n to increase verbosity. This function has no effect if callbacks are\n registered with the previous function.\n\n @param level    Level of verbosity (1 = warnings, 2 = info, 3 = debug)."]
    pub fn lldpctl_log_level(level: ::std::os::raw::c_int);
}
#[doc = " No error has happened (yet)."]
pub const lldpctl_error_t_LLDPCTL_NO_ERROR: lldpctl_error_t = 0;
#[doc = " A IO related operation would block if performed."]
pub const lldpctl_error_t_LLDPCTL_ERR_WOULDBLOCK: lldpctl_error_t = -501;
#[doc = " A IO related operation has reached a end of file condition."]
pub const lldpctl_error_t_LLDPCTL_ERR_EOF: lldpctl_error_t = -502;
#[doc = " The requested information does not exist. For example, when\n requesting an inexistant information from an atom."]
pub const lldpctl_error_t_LLDPCTL_ERR_NOT_EXIST: lldpctl_error_t = -503;
#[doc = " Cannot connect to the lldpd daemon. This error only happens with\n default synchronous handlers."]
pub const lldpctl_error_t_LLDPCTL_ERR_CANNOT_CONNECT: lldpctl_error_t = -504;
#[doc = " Atom is of incorrect type for the requested operation."]
pub const lldpctl_error_t_LLDPCTL_ERR_INCORRECT_ATOM_TYPE: lldpctl_error_t = -505;
#[doc = " An error occurred during serialization of message."]
pub const lldpctl_error_t_LLDPCTL_ERR_SERIALIZATION: lldpctl_error_t = -506;
#[doc = " The requested operation cannot be performed because we have another\n operation already running."]
pub const lldpctl_error_t_LLDPCTL_ERR_INVALID_STATE: lldpctl_error_t = -507;
#[doc = " The provided atom cannot be iterated."]
pub const lldpctl_error_t_LLDPCTL_ERR_CANNOT_ITERATE: lldpctl_error_t = -508;
#[doc = " The provided value is invalid."]
pub const lldpctl_error_t_LLDPCTL_ERR_BAD_VALUE: lldpctl_error_t = -509;
#[doc = " No new element can be created for this element."]
pub const lldpctl_error_t_LLDPCTL_ERR_CANNOT_CREATE: lldpctl_error_t = -510;
#[doc = " The library is under unexpected conditions and cannot process\n any further data reliably."]
pub const lldpctl_error_t_LLDPCTL_ERR_FATAL: lldpctl_error_t = -900;
#[doc = " Out of memory condition. Things may get havoc here but we\n should be able to recover."]
pub const lldpctl_error_t_LLDPCTL_ERR_NOMEM: lldpctl_error_t = -901;
#[doc = " An error occurred in a user provided callback."]
pub const lldpctl_error_t_LLDPCTL_ERR_CALLBACK_FAILURE: lldpctl_error_t = -902;
#[doc = " Possible error codes for functions that return negative integers on\n this purpose or for @c lldpctl_last_error()."]
pub type lldpctl_error_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Describe a provided error code.\n\n @param error Error code to be described.\n @return Statically allocated string describing the error."]
    pub fn lldpctl_strerror(error: lldpctl_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the last error associated to a connection to lldpd.\n\n @param  conn Previously allocated handler to a connection to lldpd.\n @return 0 if no error is currently registered. A negative integer\n         otherwise.\n\n For functions returning int, this function will return the same\n error number. For functions returning something else, you can use\n this function to get the appropriate error number."]
    pub fn lldpctl_last_error(conn: *mut lldpctl_conn_t) -> lldpctl_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldpctl_atom_t {
    _unused: [u8; 0],
}
#[doc = " Structure representing a map from an integer to a character string.\n\n @see lldpctl_key_get_map()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub value: ::std::os::raw::c_int,
    pub string: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
}
#[doc = " Structure representing a map from an integer to a character string.\n\n @see lldpctl_key_get_map()."]
pub type lldpctl_map_t = _bindgen_ty_1;
extern "C" {
    #[doc = " Return the reference to connection with lldpd.\n\n @param atom The atom we want reference from.\n @return The reference to the connection to lldpd.\n\n Each atom contains an internal reference to the corresponding connection to\n lldpd. Use this function to get it."]
    pub fn lldpctl_atom_get_connection(atom: *mut lldpctl_atom_t) -> *mut lldpctl_conn_t;
}
extern "C" {
    #[doc = " Increment reference count for an atom.\n\n @param atom Atom we which to increase reference count."]
    pub fn lldpctl_atom_inc_ref(atom: *mut lldpctl_atom_t);
}
extern "C" {
    #[doc = " Decrement reference count for an atom.\n\n @param atom Atom we want to decrease reference count. Can be @c NULL. In this\n             case, nothing happens.\n\n When the reference count becomes 0, the atom is freed."]
    pub fn lldpctl_atom_dec_ref(atom: *mut lldpctl_atom_t);
}
#[doc = "< The neighbor has been deleted"]
pub const lldpctl_change_t_lldpctl_c_deleted: lldpctl_change_t = 0;
#[doc = "< The neighbor has been updated"]
pub const lldpctl_change_t_lldpctl_c_updated: lldpctl_change_t = 1;
#[doc = "< This is a new neighbor"]
pub const lldpctl_change_t_lldpctl_c_added: lldpctl_change_t = 2;
#[doc = " Possible events for a change (notification).\n\n @see lldpctl_watch_callback2"]
pub type lldpctl_change_t = ::std::os::raw::c_uint;
#[doc = " Callback function invoked when a change is detected.\n\n @param conn      Connection with lldpd. Should not be used.\n @param type      Type of change detected.\n @param interface Physical interface on which the change has happened.\n @param neighbor  Changed neighbor.\n @param data      Data provided when registering the callback.\n\n The provided interface and neighbor atoms are stolen by the callback: their\n reference count are decremented when the callback ends. If you want to keep a\n reference to it, be sure to increment the reference count in the callback.\n\n @warning The provided connection should not be used at all. Do not use @c\n lldpctl_atom_set_*() functions on @c interface or @c neighbor either. If you\n do, you will get a @c LLDPCTL_ERR_INVALID_STATE error.\n\n @see lldpctl_watch_callback"]
pub type lldpctl_change_callback = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut lldpctl_conn_t,
        type_: lldpctl_change_t,
        interface: *mut lldpctl_atom_t,
        neighbor: *mut lldpctl_atom_t,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback function invoked when a change is detected.\n\n @param type      Type of change detected.\n @param interface Physical interface on which the change has happened.\n @param neighbor  Changed neighbor.\n @param data      Data provided when registering the callback.\n\n The provided interface and neighbor atoms are stolen by the callback: their\n reference count are decremented when the callback ends. If you want to keep a\n reference to it, be sure to increment the reference count in the callback.\n\n @see lldpctl_watch_callback2"]
pub type lldpctl_change_callback2 = ::std::option::Option<
    unsafe extern "C" fn(
        type_: lldpctl_change_t,
        interface: *mut lldpctl_atom_t,
        neighbor: *mut lldpctl_atom_t,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Register a callback to be called on changes.\n\n @param conn Connection with lldpd.\n @param cb   Replace the current callback with the provided one.\n @param data Data that will be passed to the callback.\n @return 0 in case of success or -1 in case of errors.\n\n This function will register the necessity to push neighbor changes to lldpd\n and therefore will issue IO operations. The error code could then be @c\n LLDPCTL_ERR_WOULDBLOCK.\n\n @warning Once a callback is registered, the connection shouldn't be used for\n anything else than receiving notifications. If you do, you will get a @c\n LLDPCTL_ERR_INVALID_STATE error.\n\n @deprecated This function is deprecated and lldpctl_watch_callback2 should be\n used instead."]
    pub fn lldpctl_watch_callback(
        conn: *mut lldpctl_conn_t,
        cb: lldpctl_change_callback,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a callback to be called on changes.\n\n @param conn Connection with lldpd.\n @param cb   Replace the current callback with the provided one.\n @param data Data that will be passed to the callback.\n @return 0 in case of success or -1 in case of errors.\n\n This function will register the necessity to push neighbor changes to lldpd\n and therefore will issue IO operations. The error code could then be @c\n LLDPCTL_ERR_WOULDBLOCK.\n\n @warning Once a callback is registered, the connection shouldn't be used for\n anything else than receiving notifications. If you do, you will get a @c\n LLDPCTL_ERR_INVALID_STATE error."]
    pub fn lldpctl_watch_callback2(
        conn: *mut lldpctl_conn_t,
        cb: lldpctl_change_callback2,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for the next change.\n\n @param conn Connection with lldpd.\n @return 0 on success or a negative integer in case of error.\n\n This function will return once a change has been detected. It is only useful\n as a main loop when using the builtin blocking IO mechanism."]
    pub fn lldpctl_watch(conn: *mut lldpctl_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve global configuration of lldpd daemon.\n\n @param conn Connection with lldpd.\n @return The global configuration or @c NULL if an error happened.\n\n This function will make IO with the daemon to get the\n configuration. Depending on the IO model, information may not be available\n right now and the function should be called again later. If @c NULL is\n returned, check the last error. If it is @c LLDPCTL_ERR_WOULDBLOCK, try again\n later."]
    pub fn lldpctl_get_configuration(conn: *mut lldpctl_conn_t) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Retrieve the list of available interfaces.\n\n @param conn Previously allocated handler to a connection to lldpd.\n @return The list of available ports or @c NULL if an error happened.\n\n This function will make IO with the daemon to get the list of\n ports. Depending on the IO model, information may not be available right now\n and the function should be called again later. If @c NULL is returned, check\n what the last error is. If it is @c LLDPCTL_ERR_WOULDBLOCK, try again later\n (when more data is available).\n\n The list of available ports can be iterated with @ref lldpctl_atom_foreach()."]
    pub fn lldpctl_get_interfaces(conn: *mut lldpctl_conn_t) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Retrieve the information related to the local chassis.\n\n @param conn Previously allocated handler to a connection to lldpd.\n @return Atom related to the local chassis which may be used in subsequent functions.\n\n This function may have to do IO to get the information related to the local\n chassis. Depending on the IO mode, information may not be available right now\n and the function should be called again later. If @c NULL is returned, check\n what the last error is. If it is @c LLDPCTL_ERR_WOULDBLOCK, try again later\n (when more data is available)."]
    pub fn lldpctl_get_local_chassis(conn: *mut lldpctl_conn_t) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Retrieve the information related to a given interface.\n\n @param port The port we want to retrieve information from. This port is an\n             atom retrieved from an interation on @c lldpctl_get_interfaces().\n @return Atom related to this port which may be used in subsequent functions.\n\n This function may have to do IO to get the information related to the given\n port. Depending on the IO mode, information may not be available right now\n and the function should be called again later. If @c NULL is returned, check\n what the last error is. If it is @c LLDPCTL_ERR_WOULDBLOCK, try again later\n (when more data is available)."]
    pub fn lldpctl_get_port(port: *mut lldpctl_atom_t) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Retrieve the default port information.\n\n This port contains default settings whenever a new port needs to be created.\n\n @param conn Previously allocated handler to a connection to lldpd.\n @return Atom of the default port which may be used in subsequent functions.\n\n This function may have to do IO to get the information related to the given\n port. Depending on the IO mode, information may not be available right now\n and the function should be called again later. If @c NULL is returned, check\n what the last error is. If it is @c LLDPCTL_ERR_WOULDBLOCK, try again later\n (when more data is available)."]
    pub fn lldpctl_get_default_port(conn: *mut lldpctl_conn_t) -> *mut lldpctl_atom_t;
}
#[doc = "< `(I,WO)` Transmit interval. When set to -1, it is meant to transmit now."]
pub const lldpctl_key_t_lldpctl_k_config_tx_interval: lldpctl_key_t = 0;
#[doc = "< `(I)` Receive only mode"]
pub const lldpctl_key_t_lldpctl_k_config_receiveonly: lldpctl_key_t = 1;
#[doc = "< `(S,WON)` Pattern to choose the management address"]
pub const lldpctl_key_t_lldpctl_k_config_mgmt_pattern: lldpctl_key_t = 2;
#[doc = "< `(S,WON)` Pattern of enabled interfaces"]
pub const lldpctl_key_t_lldpctl_k_config_iface_pattern: lldpctl_key_t = 3;
#[doc = "< `(S)` Interface pattern to choose the chassis ID"]
pub const lldpctl_key_t_lldpctl_k_config_cid_pattern: lldpctl_key_t = 4;
#[doc = "< `(S,WON)` Chassis description overridden"]
pub const lldpctl_key_t_lldpctl_k_config_description: lldpctl_key_t = 5;
#[doc = "< `(S,WON)` Platform description overridden (CDP)"]
pub const lldpctl_key_t_lldpctl_k_config_platform: lldpctl_key_t = 6;
#[doc = "< `(S,WON)` System name overridden"]
pub const lldpctl_key_t_lldpctl_k_config_hostname: lldpctl_key_t = 7;
#[doc = "< `(I)` Advertise version"]
pub const lldpctl_key_t_lldpctl_k_config_advertise_version: lldpctl_key_t = 8;
#[doc = "< `(I)` Disable LLDP-MED inventory"]
pub const lldpctl_key_t_lldpctl_k_config_lldpmed_noinventory: lldpctl_key_t = 9;
#[doc = "< `(I,WO)` lldpd is paused"]
pub const lldpctl_key_t_lldpctl_k_config_paused: lldpctl_key_t = 10;
#[doc = "< `(I,WO)` Is fast start enabled"]
pub const lldpctl_key_t_lldpctl_k_config_fast_start_enabled: lldpctl_key_t = 11;
#[doc = "< `(I,WO)` Start fast transmit interval"]
pub const lldpctl_key_t_lldpctl_k_config_fast_start_interval: lldpctl_key_t = 12;
#[doc = "< `(I,WO)` Enable or disable setting interface description"]
pub const lldpctl_key_t_lldpctl_k_config_ifdescr_update: lldpctl_key_t = 13;
#[doc = "< `(I,WO)` Enable or disable promiscuous mode on interfaces"]
pub const lldpctl_key_t_lldpctl_k_config_iface_promisc: lldpctl_key_t = 14;
#[doc = "< `(I,WO)` Enable or disable chassis capabilities advertisement"]
pub const lldpctl_key_t_lldpctl_k_config_chassis_cap_advertise: lldpctl_key_t = 15;
#[doc = "< `(I,WO)` Enable or disable management addresses advertisement"]
pub const lldpctl_key_t_lldpctl_k_config_chassis_mgmt_advertise: lldpctl_key_t = 16;
#[doc = "< `(S,WON)` User defined string for the chassis ID"]
pub const lldpctl_key_t_lldpctl_k_config_cid_string: lldpctl_key_t = 17;
#[doc = "< `(S,WON)` Pattern of permanent interfaces"]
pub const lldpctl_key_t_lldpctl_k_config_perm_iface_pattern: lldpctl_key_t = 18;
#[doc = "< `(I,WO)` Transmit interval in milliseconds. Set to -1 to transmit now."]
pub const lldpctl_key_t_lldpctl_k_config_tx_interval_ms: lldpctl_key_t = 19;
#[doc = "< `(S)` The interface name."]
pub const lldpctl_key_t_lldpctl_k_interface_name: lldpctl_key_t = 1000;
#[doc = "< `(S)` The port name. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_port_name: lldpctl_key_t = 1100;
#[doc = "< `(I)` The port index. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_port_index: lldpctl_key_t = 1101;
#[doc = " `(AL)` The list of known neighbors for this port.\n\n A neighbor is in fact a remote port."]
pub const lldpctl_key_t_lldpctl_k_port_neighbors: lldpctl_key_t = 1200;
#[doc = "< `(IS)` The protocol that was used to retrieve this information."]
pub const lldpctl_key_t_lldpctl_k_port_protocol: lldpctl_key_t = 1201;
#[doc = "< `(I)`  Age of information, seconds from epoch."]
pub const lldpctl_key_t_lldpctl_k_port_age: lldpctl_key_t = 1202;
#[doc = "< `(IS)` The subtype ID of this port."]
pub const lldpctl_key_t_lldpctl_k_port_id_subtype: lldpctl_key_t = 1203;
#[doc = "< `(BS,WO)` The ID of this port."]
pub const lldpctl_key_t_lldpctl_k_port_id: lldpctl_key_t = 1204;
#[doc = "< `(S,WO)` The description of this port."]
pub const lldpctl_key_t_lldpctl_k_port_descr: lldpctl_key_t = 1205;
#[doc = "< `(I)` Is this port hidden (or should it be displayed?)?"]
pub const lldpctl_key_t_lldpctl_k_port_hidden: lldpctl_key_t = 1206;
#[doc = "< `(IS,WO)` Operational status of this (local) port"]
pub const lldpctl_key_t_lldpctl_k_port_status: lldpctl_key_t = 1207;
#[doc = "< `(A)` Chassis associated to the port"]
pub const lldpctl_key_t_lldpctl_k_port_chassis: lldpctl_key_t = 1208;
#[doc = "< `(I)` TTL for port, 0 if info is attached to chassis"]
pub const lldpctl_key_t_lldpctl_k_port_ttl: lldpctl_key_t = 1209;
#[doc = "< `(I,W)` VLAN tag for TX on port, -1 VLAN disabled"]
pub const lldpctl_key_t_lldpctl_k_port_vlan_tx: lldpctl_key_t = 1210;
#[doc = "< `(I)` MFS"]
pub const lldpctl_key_t_lldpctl_k_port_dot3_mfs: lldpctl_key_t = 1300;
#[doc = "< `(I)` Port aggregation ID"]
pub const lldpctl_key_t_lldpctl_k_port_dot3_aggregid: lldpctl_key_t = 1301;
#[doc = "< `(I)` Autonegotiation support."]
pub const lldpctl_key_t_lldpctl_k_port_dot3_autoneg_support: lldpctl_key_t = 1302;
#[doc = "< `(I)` Autonegotiation enabled."]
pub const lldpctl_key_t_lldpctl_k_port_dot3_autoneg_enabled: lldpctl_key_t = 1303;
#[doc = "< `(I)` Advertised protocols. See `LLDP_DOT3_LINK_AUTONEG_*`"]
pub const lldpctl_key_t_lldpctl_k_port_dot3_autoneg_advertised: lldpctl_key_t = 1304;
#[doc = "< `(IS)` Current MAU type. See `LLDP_DOT3_MAU_*`"]
pub const lldpctl_key_t_lldpctl_k_port_dot3_mautype: lldpctl_key_t = 1305;
#[doc = "< `(A,WO)` Dot3 power related stuff."]
pub const lldpctl_key_t_lldpctl_k_port_dot3_power: lldpctl_key_t = 1400;
#[doc = "< `(IS,W)` Device type. See `LLDP_DOT3_POWER_PSE/PD`"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_devicetype: lldpctl_key_t = 1401;
#[doc = "< `(I,W)` Is MDI power supported."]
pub const lldpctl_key_t_lldpctl_k_dot3_power_supported: lldpctl_key_t = 1402;
#[doc = "< `(I,W)` Is MDI power enabled."]
pub const lldpctl_key_t_lldpctl_k_dot3_power_enabled: lldpctl_key_t = 1403;
#[doc = "< `(I,W)` Pair-control enabled?"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_paircontrol: lldpctl_key_t = 1404;
#[doc = "< `(IS,W)` See `LLDP_DOT3_POWERPAIRS_*`"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_pairs: lldpctl_key_t = 1405;
#[doc = "< `(IS,W)` Power class."]
pub const lldpctl_key_t_lldpctl_k_dot3_power_class: lldpctl_key_t = 1406;
#[doc = "< `(I,W)` 802.3AT power type"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_type: lldpctl_key_t = 1407;
#[doc = "< `(IS,W)` 802.3AT power source"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_source: lldpctl_key_t = 1408;
#[doc = "< `(IS,W)` 802.3AT power priority"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_priority: lldpctl_key_t = 1409;
#[doc = "< `(I,W)` 802.3AT power allocated"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_allocated: lldpctl_key_t = 1410;
#[doc = "< `(I,W)` 802.3AT power requested"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_requested: lldpctl_key_t = 1411;
#[doc = "< `(IS,W)` 802.3BT both modes supported?"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_pd_4pid: lldpctl_key_t = 1412;
#[doc = "< `(I,W)` 802.3BT power value requested for A"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_requested_a: lldpctl_key_t = 1413;
#[doc = "< `(I,W)` 802.3BT power value requested for B"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_requested_b: lldpctl_key_t = 1414;
#[doc = "< `(I,W)` 802.3BT power value allocated for A"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_allocated_a: lldpctl_key_t = 1415;
#[doc = "< `(I,W)` 802.3BT power value allocated for B"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_allocated_b: lldpctl_key_t = 1416;
#[doc = "< `(IS,W)` 802.3BT PSE powering status"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_pse_status: lldpctl_key_t = 1417;
#[doc = "< `(IS,W)` 802.3BT PD powering status"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_pd_status: lldpctl_key_t = 1418;
#[doc = "< `(IS,W)` 802.3BT PSE power pairs"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_pse_pairs_ext: lldpctl_key_t = 1419;
#[doc = "< `(IS,W)` 802.3BT power class for A"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_class_a: lldpctl_key_t = 1420;
#[doc = "< `(IS,W)` 802.3BT power class for B"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_class_b: lldpctl_key_t = 1421;
#[doc = "< `(IS,W)` 802.3BT power class"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_class_ext: lldpctl_key_t = 1422;
#[doc = "< `(IS,W)` 802.3BT power type"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_type_ext: lldpctl_key_t = 1423;
#[doc = "< `(IS,W)` 802.3BT dualsig isolated?"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_pd_load: lldpctl_key_t = 1424;
#[doc = "< `(I,W)` 802.3BT maximum available power"]
pub const lldpctl_key_t_lldpctl_k_dot3_power_pse_max: lldpctl_key_t = 1425;
#[doc = "< `(I)` Primary VLAN ID"]
pub const lldpctl_key_t_lldpctl_k_port_vlan_pvid: lldpctl_key_t = 1500;
#[doc = "< `(AL)` List of VLAN"]
pub const lldpctl_key_t_lldpctl_k_port_vlans: lldpctl_key_t = 1501;
#[doc = "< `(I)` VLAN ID"]
pub const lldpctl_key_t_lldpctl_k_vlan_id: lldpctl_key_t = 1502;
#[doc = "< `(S)` VLAN name"]
pub const lldpctl_key_t_lldpctl_k_vlan_name: lldpctl_key_t = 1503;
#[doc = "< `(AL)` List of PPVIDs"]
pub const lldpctl_key_t_lldpctl_k_port_ppvids: lldpctl_key_t = 1600;
#[doc = "< `(I)` Status of PPVID (see `LLDP_PPVID_CAP_*`)"]
pub const lldpctl_key_t_lldpctl_k_ppvid_status: lldpctl_key_t = 1601;
#[doc = "< `(I)` ID of PPVID"]
pub const lldpctl_key_t_lldpctl_k_ppvid_id: lldpctl_key_t = 1602;
#[doc = "< `(AL)` List of PIDs"]
pub const lldpctl_key_t_lldpctl_k_port_pis: lldpctl_key_t = 1700;
#[doc = "< `(B)` PID value"]
pub const lldpctl_key_t_lldpctl_k_pi_id: lldpctl_key_t = 1701;
#[doc = "< `(I)` The chassis index."]
pub const lldpctl_key_t_lldpctl_k_chassis_index: lldpctl_key_t = 1800;
#[doc = "< `(IS)` The subtype ID of this chassis."]
pub const lldpctl_key_t_lldpctl_k_chassis_id_subtype: lldpctl_key_t = 1801;
#[doc = "< `(BS)` The ID of this chassis."]
pub const lldpctl_key_t_lldpctl_k_chassis_id: lldpctl_key_t = 1802;
#[doc = "< `(S)` The name of this chassis."]
pub const lldpctl_key_t_lldpctl_k_chassis_name: lldpctl_key_t = 1803;
#[doc = "< `(S)` The description of this chassis."]
pub const lldpctl_key_t_lldpctl_k_chassis_descr: lldpctl_key_t = 1804;
#[doc = "< `(I)` Available capabalities (see `LLDP_CAP_*`)"]
pub const lldpctl_key_t_lldpctl_k_chassis_cap_available: lldpctl_key_t = 1805;
#[doc = "< `(I)` Enabled capabilities (see `LLDP_CAP_*`)"]
pub const lldpctl_key_t_lldpctl_k_chassis_cap_enabled: lldpctl_key_t = 1806;
#[doc = "< `(AL)` List of management addresses"]
pub const lldpctl_key_t_lldpctl_k_chassis_mgmt: lldpctl_key_t = 1807;
#[doc = "< Deprecated"]
pub const lldpctl_key_t_lldpctl_k_chassis_ttl: lldpctl_key_t = 1808;
#[doc = "< `(IS)` Chassis MED type. See `LLDP_MED_CLASS_*`"]
pub const lldpctl_key_t_lldpctl_k_chassis_med_type: lldpctl_key_t = 1900;
#[doc = "< `(I)` Available MED capabilitied. See `LLDP_MED_CAP_*`"]
pub const lldpctl_key_t_lldpctl_k_chassis_med_cap: lldpctl_key_t = 1901;
#[doc = "< `(S)` LLDP MED inventory \"Hardware Revision\""]
pub const lldpctl_key_t_lldpctl_k_chassis_med_inventory_hw: lldpctl_key_t = 1902;
#[doc = "< `(S)` LLDP MED inventory \"Software Revision\""]
pub const lldpctl_key_t_lldpctl_k_chassis_med_inventory_sw: lldpctl_key_t = 1903;
#[doc = "< `(S)` LLDP MED inventory \"Firmware Revision\""]
pub const lldpctl_key_t_lldpctl_k_chassis_med_inventory_fw: lldpctl_key_t = 1904;
#[doc = "< `(S)` LLDP MED inventory \"Serial Number\""]
pub const lldpctl_key_t_lldpctl_k_chassis_med_inventory_sn: lldpctl_key_t = 1905;
#[doc = "< `(S)` LLDP MED inventory \"Manufacturer\""]
pub const lldpctl_key_t_lldpctl_k_chassis_med_inventory_manuf: lldpctl_key_t = 1906;
#[doc = "< `(S)` LLDP MED inventory \"Model\""]
pub const lldpctl_key_t_lldpctl_k_chassis_med_inventory_model: lldpctl_key_t = 1907;
#[doc = "< `(S)` LLDP MED inventory \"Asset ID\""]
pub const lldpctl_key_t_lldpctl_k_chassis_med_inventory_asset: lldpctl_key_t = 1908;
#[doc = "< `(AL,WO)` MED policies attached to a port."]
pub const lldpctl_key_t_lldpctl_k_port_med_policies: lldpctl_key_t = 2000;
#[doc = "< `(IS,W)` MED policy app type. See `LLDP_MED_APPTYPE_*`. 0 if a policy is not defined."]
pub const lldpctl_key_t_lldpctl_k_med_policy_type: lldpctl_key_t = 2001;
#[doc = "< `(I,W)` Is MED policy defined?"]
pub const lldpctl_key_t_lldpctl_k_med_policy_unknown: lldpctl_key_t = 2002;
#[doc = "< `(I,W)` MED policy tagging"]
pub const lldpctl_key_t_lldpctl_k_med_policy_tagged: lldpctl_key_t = 2003;
#[doc = "< `(I,W)` MED policy VID"]
pub const lldpctl_key_t_lldpctl_k_med_policy_vid: lldpctl_key_t = 2004;
#[doc = "< `(I,W)` MED policy priority"]
pub const lldpctl_key_t_lldpctl_k_med_policy_priority: lldpctl_key_t = 2005;
#[doc = "< `(I,W)` MED policy DSCP"]
pub const lldpctl_key_t_lldpctl_k_med_policy_dscp: lldpctl_key_t = 2006;
#[doc = "< `(AL,WO)` MED locations attached to a port."]
pub const lldpctl_key_t_lldpctl_k_port_med_locations: lldpctl_key_t = 2100;
#[doc = "< `(IS,W)` MED location format. See\n `LLDP_MED_LOCFORMAT_*`. 0 if this\n location is not defined. When written,\n the following fields will be zeroed\n out."]
pub const lldpctl_key_t_lldpctl_k_med_location_format: lldpctl_key_t = 2101;
#[doc = "< `(IS,W)` MED geoid. See `LLDP_MED_LOCATION_GEOID_*`. Only if format is COORD."]
pub const lldpctl_key_t_lldpctl_k_med_location_geoid: lldpctl_key_t = 2102;
#[doc = "< `(S,W)` MED latitude. Only if format is COORD."]
pub const lldpctl_key_t_lldpctl_k_med_location_latitude: lldpctl_key_t = 2103;
#[doc = "< `(S,W)` MED longitude. Only if format is COORD."]
pub const lldpctl_key_t_lldpctl_k_med_location_longitude: lldpctl_key_t = 2104;
#[doc = "< `(S,W)` MED altitude. Only if format is COORD."]
pub const lldpctl_key_t_lldpctl_k_med_location_altitude: lldpctl_key_t = 2105;
#[doc = "< `(S,W)` MED altitude unit. See `LLDP_MED_LOCATION_ALTITUDE_UNIT_*`.\n Only if format is COORD."]
pub const lldpctl_key_t_lldpctl_k_med_location_altitude_unit: lldpctl_key_t = 2106;
#[doc = "< `(S,W)` MED country. Only if format is CIVIC."]
pub const lldpctl_key_t_lldpctl_k_med_location_country: lldpctl_key_t = 2200;
#[doc = "< `(S,W)` MED ELIN. Only if format is ELIN."]
pub const lldpctl_key_t_lldpctl_k_med_location_elin: lldpctl_key_t = 2201;
#[doc = "< `(AL,WC)` MED civic address elements. Only if format is CIVIC"]
pub const lldpctl_key_t_lldpctl_k_med_location_ca_elements: lldpctl_key_t = 2300;
#[doc = "< `(IS,W)` MED civic address type."]
pub const lldpctl_key_t_lldpctl_k_med_civicaddress_type: lldpctl_key_t = 2301;
#[doc = "< `(S,W)` MED civic address value."]
pub const lldpctl_key_t_lldpctl_k_med_civicaddress_value: lldpctl_key_t = 2302;
#[doc = "< `(A,WO)` LLDP-MED power related stuff."]
pub const lldpctl_key_t_lldpctl_k_port_med_power: lldpctl_key_t = 2400;
#[doc = "< `(IS,W)` LLDP MED power device type. See `LLDP_MED_POW_TYPE_*`"]
pub const lldpctl_key_t_lldpctl_k_med_power_type: lldpctl_key_t = 2401;
#[doc = "< `(IS,W)` LLDP MED power source. See `LLDP_MED_POW_SOURCE_*`"]
pub const lldpctl_key_t_lldpctl_k_med_power_source: lldpctl_key_t = 2402;
#[doc = "< `(IS,W)` LLDP MED power priority. See `LLDP_MED_POW_PRIO_*`"]
pub const lldpctl_key_t_lldpctl_k_med_power_priority: lldpctl_key_t = 2403;
#[doc = "< `(I,W)` LLDP MED power value"]
pub const lldpctl_key_t_lldpctl_k_med_power_val: lldpctl_key_t = 2404;
#[doc = "< `(S)` IP address"]
pub const lldpctl_key_t_lldpctl_k_mgmt_ip: lldpctl_key_t = 3000;
#[doc = "< `(I)` Interface index"]
pub const lldpctl_key_t_lldpctl_k_mgmt_iface_index: lldpctl_key_t = 30001;
#[doc = "< `(I)` tx cnt. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_tx_cnt: lldpctl_key_t = 4000;
#[doc = "< `(I)` rx cnt. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_rx_cnt: lldpctl_key_t = 4001;
#[doc = "< `(I)` discarded cnt. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_rx_discarded_cnt: lldpctl_key_t = 4002;
#[doc = "< `(I)` unrecognized cnt. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_rx_unrecognized_cnt: lldpctl_key_t = 4003;
#[doc = "< `(I)` ageout cnt. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_ageout_cnt: lldpctl_key_t = 4004;
#[doc = "< `(I)` insert cnt. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_insert_cnt: lldpctl_key_t = 4005;
#[doc = "< `(I)` delete cnt. Only works for a local port."]
pub const lldpctl_key_t_lldpctl_k_delete_cnt: lldpctl_key_t = 4006;
#[doc = "< `(I,WO)` Transmit hold interval."]
pub const lldpctl_key_t_lldpctl_k_config_tx_hold: lldpctl_key_t = 4007;
#[doc = "< `(I,WO)` bond slave src mac type."]
pub const lldpctl_key_t_lldpctl_k_config_bond_slave_src_mac_type: lldpctl_key_t = 4008;
#[doc = "< `(I,WO)` LLDP PortID TLV Subtype"]
pub const lldpctl_key_t_lldpctl_k_config_lldp_portid_type: lldpctl_key_t = 4009;
#[doc = "< `(I,WO)` LLDP agent type"]
pub const lldpctl_key_t_lldpctl_k_config_lldp_agent_type: lldpctl_key_t = 4010;
#[doc = "< `(I,WO)`Maximum number of neighbors per port."]
pub const lldpctl_key_t_lldpctl_k_config_max_neighbors: lldpctl_key_t = 4011;
#[doc = "< `(AL)` custom TLVs"]
pub const lldpctl_key_t_lldpctl_k_custom_tlvs: lldpctl_key_t = 5000;
pub const lldpctl_key_t_lldpctl_k_custom_tlvs_clear: lldpctl_key_t = 5001;
#[doc = " `(I,WO)` clear list of custom TLVs"]
pub const lldpctl_key_t_lldpctl_k_custom_tlv: lldpctl_key_t = 5002;
#[doc = "< `(I,WO)` custom TLV Organizationally Unique Identifier. Default is 0 (3 bytes)"]
pub const lldpctl_key_t_lldpctl_k_custom_tlv_oui: lldpctl_key_t = 5003;
#[doc = "< `(I,WO)` custom TLV subtype. Default is 0 (1 byte)"]
pub const lldpctl_key_t_lldpctl_k_custom_tlv_oui_subtype: lldpctl_key_t = 5004;
#[doc = "< `(I,WO)` custom TLV Organizationally Unique Identifier Information String (up to 507 bytes)"]
pub const lldpctl_key_t_lldpctl_k_custom_tlv_oui_info_string: lldpctl_key_t = 5005;
#[doc = "< `(I,WO)` custom TLV operation"]
pub const lldpctl_key_t_lldpctl_k_custom_tlv_op: lldpctl_key_t = 5006;
#[doc = " Piece of information that can be retrieved from/written to an atom.\n\n Each piece of information can potentially be retrieved as an atom (A), a\n string (S), a buffer (B) or an integer (I). Additionaly, when an information\n can be retrieved as an atom, it is usually iterable (L). When an atom can be\n retrieved as a string and as an additional type, the string is expected to be\n formatted. For example, the MAC address of a local port can be retrieved as a\n buffer and a string. As a string, you'll get something like\n \"00:11:22:33:44:55\". Also, all values that can be get as an integer or a\n buffer can be get as a string too. There is no special formatting in this\n case. \"(BS)\" means that the string get a special appropriate format.\n\n The name of a key is an indication on the type of atom that information can\n be extracted from. For example, @c lldpctl_k_med_policy_type can be extracted\n from an atom you got by iterating on @c lldpctl_k_port_med_policies. On the\n other hand, @c lldpctl_k_port_descr and @c lldpctl_k_chassis can be retrieved\n from an atom retrieved either by iterating @c lldpctl_k_port_neighbors or\n with @c lldpctl_get_port().\n\n Some values may be written. They are marked with (W). Such a change may or\n may not be transmitted immediatly. If they are not transmitted immediatly,\n this means that the resulting atom should be written to another atom. For\n example, when writting @c lldpctl_k_med_policy_tagged, you need to write the\n resulting atom to @c lldpctl_k_port_med_policies. If the change is\n transmitted immediatly, you need to check the error status of the connection\n to know if it has been transmitted correctly. Notably, if you get @c\n LLDPCTL_ERR_WOULDBLOCK, you need to try again later. Usually, changes are\n transmitted immediatly. The exception are changes that need to be grouped to\n be consistent, like a LLDP MED location. When a change is transmitted\n immediatly, it is marked with (O). @c lldpctl_atom_set_str() may accept a @c\n NULL value. This case is marked with (N) and usually reset the item to the\n default value or no value.\n\n Some values may also be created. They are flagged with (C). This only applies\n to elements that can be iterated (L) and written (W). The element created\n still needs to be appended to the list by being written to it. The creation\n is done with @c lldpctl_atom_create().\n\n An atom marked with (S) can be retrieved as a string only. It cannot be\n written. An atom marked with (IS) can be retrieved as an integer and features\n an appropriate representation as a string (usually, the name of a constant)\n which is more meaningful than just the integer. An atom marked as (I) can be\n retrieved as an integer and as a string. In the later case, this is just a\n string representation of the integer. An atom marked with (AL) can be\n retrieved as an atom only and can be iterated over. This is usually a list of\n things. An atom marked (I,W) can be read as an integer or a string and can be\n written as an integer. The change would not be commited until the atom is\n written to the nearest atom supporting (A,WO) operation (eventually with an\n indirection, i.e first write to a (A,W), then to a (A,WO))."]
pub type lldpctl_key_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get a map related to a key.\n\n Many keys expect to be written with a discrete number of values. Take for\n example @c lldpctl_k_med_civicaddress_type, it can take any integer between 1\n and 128. However, each integer can be named. It can be useful for an\n application to get a translation between the integer that can be provided and\n a more human-readable name. This function allows to retrieve the\n corresponding map.\n\n @param key    The piece of information we want a map from.\n @return       The map or @c NULL if no map is available.\n\n The returned map has its last element set to 0. It is also expected that the\n string value can be used with a set operation. It will be translated to the\n integer value."]
    pub fn lldpctl_key_get_map(key: lldpctl_key_t) -> *const _bindgen_ty_1;
}
extern "C" {
    #[doc = " Retrieve a bit of information as an atom.\n\n @param atom The atom we want to query.\n @param key  The information we want from the atom.\n @return The atom representing the requested information or @c NULL if the\n         information is not available.\n\n Not every value of @c info will be available as an atom. See the\n documentation of @c lldpctl_key_t for values accepting to be extracted as an\n atom. Usually, this is only iterable values or values representing a complex\n object.\n\n The provided atom is not a _borrowed_ reference. You need to decrement the\n reference count when you don't need it anymore.\n\n As a convenience, this function will return @c NULL if the first parameter is\n @c NULL and no error will be raised."]
    pub fn lldpctl_atom_get(atom: *mut lldpctl_atom_t, key: lldpctl_key_t) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Set a bit of information with an atom.\n\n @param atom  The atom we want to write to.\n @param key   The key information we want to write.\n @param value The value of the information we want to write.\n @return The updated atom with the appropriate information.\n\n This function will return @c NULL in case of error. If the last error is @c\n LLDPCTL_ERR_WOULDBLOCK, the write should be retried later with the exact same\n parameters. LLDPCTL_ERR_BAD_VALUE is raised when the provided atom is not\n correct."]
    pub fn lldpctl_atom_set(
        atom: *mut lldpctl_atom_t,
        key: lldpctl_key_t,
        value: *mut lldpctl_atom_t,
    ) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Retrieve a bit of information as a null-terminated string.\n\n @param atom The atom we want to query.\n @param key  The information we want from the atom.\n @return The requested string or @c NULL if the information is not available.\n\n Not every value of @c info will be available as a string. See the\n documentation of @c lldpctl_key_t for values accepting to be extracted as a\n string. Usually, only piece of information stored as string are available in\n this form but sometimes, you can get a nice formatted string instead of an\n integer with this function.\n\n As a convenience, this function will return @c NULL if the first parameter is\n @c NULL and no error will be raised.\n\n The provided string may live inside the atom providing it. If you need it\n longer, duplicate it."]
    pub fn lldpctl_atom_get_str(
        atom: *mut lldpctl_atom_t,
        key: lldpctl_key_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set a bit of information using a null-terminated string.\n\n @param atom  The atom we want to write to.\n @param key   The key information we want to write.\n @param value The value of the information we want to write.\n @return The updated atom with the appropriate information.\n\n This function will return @c NULL in case of error. If the last error is @c\n LLDPCTL_ERR_WOULDBLOCK, the write should be retried later with the exact same\n parameters. LLDPCTL_ERR_BAD_VALUE is raised when the provided atom is not\n correct."]
    pub fn lldpctl_atom_set_str(
        atom: *mut lldpctl_atom_t,
        key: lldpctl_key_t,
        value: *const ::std::os::raw::c_char,
    ) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Retrieve a bit of information as a buffer.\n\n @param atom        The atom we want to query.\n @param key         The information we want from the atom.\n @param[out] length The size of the returned buffer.\n @return The requested buffer or @c NULL if the information is not available.\n\n Not every value of @c info will be available as a buffer. See the\n documentation of @c lldpctl_key_t for values accepting to be extracted as a\n string. Usually, only piece of information stored as buffer are available in\n this form.\n\n As a convenience, this function will return @c NULL if the first parameter is\n @c NULL and no error will be raised. If this function returns @c NULL, the\n third parameter is set to 0.\n\n The provided buffer may live inside the atom providing it. If you need it\n longer, duplicate it."]
    pub fn lldpctl_atom_get_buffer(
        atom: *mut lldpctl_atom_t,
        key: lldpctl_key_t,
        length: *mut usize,
    ) -> *const u8;
}
extern "C" {
    #[doc = " Set a bit of information using a buffer\n\n @param atom   The atom we want to write to.\n @param key    The key information we want to write.\n @param value  The value of the information we want to write.\n @param length The length of the provided buffer.\n @return The updated atom with the appropriate information.\n\n This function will return @c NULL in case of error. If the last error is @c\n LLDPCTL_ERR_WOULDBLOCK, the write should be retried later with the exact same\n parameters. LLDPCTL_ERR_BAD_VALUE is raised when the provided atom is not\n correct."]
    pub fn lldpctl_atom_set_buffer(
        atom: *mut lldpctl_atom_t,
        key: lldpctl_key_t,
        value: *const u8,
        length: usize,
    ) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Retrieve a bit of information as an integer.\n\n @param atom The atom we want to query.\n @param key  The information we want from the atom.\n @return The requested integer or -1 if the information is not available\n\n Not every value of @c info will be available as an integer. See the\n documentation of @c lldpctl_key_t for values accepting to be extracted as a\n string. Usually, only piece of information stored as an integer are available\n in this form.\n\n Only @c lldpctl_last_error() can tell if the returned value is an error or\n not. However, most values extracted from lldpd cannot be negative."]
    pub fn lldpctl_atom_get_int(
        atom: *mut lldpctl_atom_t,
        key: lldpctl_key_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Set a bit of information using an integer\n\n @param atom   The atom we want to write to.\n @param key    The key information we want to write.\n @param value  The value of the information we want to write.\n @return The updated atom with the appropriate information.\n\n This function will return @c NULL in case of error. If the last error is @c\n LLDPCTL_ERR_WOULDBLOCK, the write should be retried later with the exact same\n parameters. LLDPCTL_ERR_BAD_VALUE is raised when the provided atom is not\n correct."]
    pub fn lldpctl_atom_set_int(
        atom: *mut lldpctl_atom_t,
        key: lldpctl_key_t,
        value: ::std::os::raw::c_long,
    ) -> *mut lldpctl_atom_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldpctl_atom_iter_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return an iterator over a given atom.\n\n If an atom is iterable (if it is a list, like a list of ports, a list of\n VLAN, a list of neighbors), it is possible to iterate over it. First use this\n function to get an iterator then use @c lldpctl_atom_iter_next() to get the\n next item and @c lldpctl_atom_iter_value() to the actuel item.\n\n @param atom The atom we want to create an iterator from.\n @return The iterator or @c NULL if an error happened or if the atom is empty\n         (check with @c lldpctl_last_error()).\n\n As a convenience, if the provided atom is @c NULL, this function will return\n @c NULL and no error will be raised."]
    pub fn lldpctl_atom_iter(atom: *mut lldpctl_atom_t) -> *mut lldpctl_atom_iter_t;
}
extern "C" {
    #[doc = " Return the next element of an iterator.\n\n @param atom The atom we are currently iterating.\n @param iter The iterator we want the next element from.\n @return An iterator starting on the next element or @c NULL if we have no\n         more elements\n\n @see lldpctl_atom_iter(), lldpctl_atom_iter_value().\n\n As a convenience, if the provided atom is @c NULL, this function will return\n @c NULL and no error will be raised."]
    pub fn lldpctl_atom_iter_next(
        atom: *mut lldpctl_atom_t,
        iter: *mut lldpctl_atom_iter_t,
    ) -> *mut lldpctl_atom_iter_t;
}
extern "C" {
    #[doc = " Return the value of an iterator.\n\n @param atom The atom we are currently iterating.\n @param iter The iterator we want the next element from.\n @return The atom currently associated with the iterator.\n\n @see lldpctl_atom_iter(), lldpctl_atom_iter_next()."]
    pub fn lldpctl_atom_iter_value(
        atom: *mut lldpctl_atom_t,
        iter: *mut lldpctl_atom_iter_t,
    ) -> *mut lldpctl_atom_t;
}
extern "C" {
    #[doc = " Create a new value for an iterable element.\n\n The value is meant to be appended using @c lldpctl_atom_set(). Currently,\n there is no way to delete an element from a list. It is also not advisable to\n use getters on a newly created object until it is fully initialized. If its\n internal representation is using a buffer, it may not be initialized until\n the first set.\n\n @param atom The atom we want to create a new element for.\n @return The new element."]
    pub fn lldpctl_atom_create(atom: *mut lldpctl_atom_t) -> *mut lldpctl_atom_t;
}
